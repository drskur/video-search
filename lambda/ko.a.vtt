WEBVTT

00:00:01.240 --> 00:00:04.599
안녕하세요, 오늘 참여해 주셔서 감사합니다.

00:00:04.610 --> 00:00:10.500
제 이름은 미라지이고 저는 싱가포르에서 자동차 운전 엔지니어 중 한 명입니다.

00:00:10.510 --> 00:00:20.350
저는 오늘 여행을위한 음식 배달 솔루션 인 지난 몇 달 동안 우리가 작업해온 시위 중 하나 인 그렉과 함께 발표 될 것입니다.

00:00:20.350 --> 00:00:45.560
Oka, 오늘의 의제는 다음과 같습니다. 우리는 어 고객을 소개하는 것으로 시작합니다. 프로토 타입을 통해 우리를 이끄는 문제 진술은 무엇입니까?프로토 타입에 대해 매우 높은 수준의 기술적 접근 방식을 취한 다음 데모를 통해 프레젠테이션을 중단하고 실제로 고객에게 제공 한 내용을 보여줍니다.

00:00:45.569 --> 00:01:03.060
그런 다음 Greg는 다음 부분을 인수하여 프로토 타입 전체에서 배운 과제, 솔루션 및 교훈, 고객 및 고객에게 미친 영향에 대해 이야기 할 것입니다.다시 유용성.

00:01:05.139 --> 00:01:19.440
그래서 우선, 누가 모르는 여행 로카 (Loca) 는 인도네시아 유니콘 중 하나이며 아시아 지역에서 활동하고 있으며 뉴질랜드에서도 아마도 연말 내내 공개된다고합니다.

00:01:19.449 --> 00:01:38.160
어, 온라인 여행사로 시작했지만 오늘날에는 플라이 호텔, 기차 및 여행 패키지와 같은 레거시뿐만 아니라 음식 배달을 임대하는 베가와 관련된 다른 종류의 솔루션도 다양한 서비스를 제공합니다.

00:01:38.639 --> 00:02:02.599
이 특정 프로토 타입의 매장 인 어 (uh the) 에서 6 천만 건 이상의 다운로드를 제공하는 슈퍼 앱으로서의 목표는 개편하려는 사업부 인 여행 로케와 연락을 취했습니다. 내부 드라이브를 추가하여 현재 제공되는 제품은 기존 외부 제공 업체와 통합됩니다.

00:02:02.610 --> 00:02:12.029
그래서 루카를 여행하는 대부분의 비즈니스를 프로토 타입하기 전에는 실제로 외부 공급자가 독점적으로 사용했습니다.

00:02:12.039 --> 00:02:18.559
따라서 플랫폼에 들어오는 모든 주문은 다른 배송 파트너에게 업로드되었습니다.

00:02:18.639 --> 00:02:30.160
프로토 타입을 통해 우리는 실제로 이러한 주문을 이행하고 최종 고객에게 배송 할 내부 운전자가 도망가는 것에 대해 논의하기 시작했습니다.

00:02:31.740 --> 00:02:42.389
프로토 타입의 초기 단계에서 우리가 모은 지방 성명서는 실제로 현지 여행을 떠나는 것에 관한 것입니다.

00:02:42.399 --> 00:03:03.660
운전자를 검색하고 어떤 운전자에게 주문을 할당해야하는지, 그리고 그런 종류의 어, 정말 높은 수준의 문제 진술은 운전자가 저울을 추적하고 실제로 해당 주문을 이행하는 데 사용할 수있는 운전자를 결정해야합니다.

00:03:04.240 --> 00:03:12.839
또한 운전자 행동을 분석하려면 향후 사용을 위해 과거 데이터를 사용할 수 있어야하고 이로부터 파생된 솔루션을 추적해야 합니다.

00:03:12.850 --> 00:03:47.460
어, 비용 효율적이고 비용 효율적이며 신사, 여행 로컬 솔루션과 통합되면서 수요를 충족하도록 확장 할 수 있어야합니다. 여행 지역 솔루션은 여행 운전자에게 주문을 분배하기 위해 이미 구축하고있었습니다.여러 서비스에서 발생하는 많은 복잡한 요소의 의견을 고려하는 동시에 고객 경험을 위해 수천 명의 드라이버에 대한 비용을 동시에 최적화해야하는 타사 제공 업체를 포함합니다.

00:03:47.839 --> 00:04:11.960
그래서 국제적으로 고객은 운전자들 사이에 질서를 분배하는 데 도움이 될 정말 간단한 솔루션을 원했습니다. 이 솔루션은 복잡한 안무를 대규모로 추상화하고 고객이 배우면서 실험하고 조정하기 위해 쉽고 쉽게 변경 및 조정하고 수정할 수있었습니다.

00:04:13.539 --> 00:04:29.359
그래서 우리가 이 문제를 분석했을 때, 우리는 꽤 다른 몇 가지가 있다는 것을 깨달았습니다. 아시다시피, 거기에 붙어있는 문제들, 많은 문제들, 아시다시피, 우리는 그것들을 몇 가지 어 단계로 그룹화할 수 있고 그것이 우리가 프로토타입을 전달하는 방법이기도 합니다.

00:04:29.369 --> 00:04:35.130
그래서 우리는 어 추적 운전자 규모를 다루는 것으로 시작했습니다.

00:04:35.140 --> 00:05:13.149
그래서 첫 번째 단계는 우리가 약 2 주를 보냈다는 것입니다. 그리고 우리는 운전자의 함대에서 오는 데이터 위치 데이터에서 부상을 입을 수있는 능력을 제공하고 그것을 데이터 저장소에 넣었습니다.지오 펜싱, Patel과 같은 추가 미래는 고객이나 식당에 알리고 운전자가 대상 목적지에 가깝습니다.

00:05:13.160 --> 00:05:21.350
1 단계보다 상당히 복잡했던 2 단계는 약 67 주가 조금 더 걸렸습니다.

00:05:21.350 --> 00:06:11.739
그리고 그 당시 우리는 실제로 어 공급자를 추상화하려고 노력하는 데 주로 보냈습니다. 어, 알다시피, 어떤 종류의 어, 시스템에서 공급자를 쉽게 추가하거나 제거 할 수있는 방법을 갖기 위해 고객에게 제공하고 싶었던 제공 계층이라고 말하고 싶습니다.들어오는 주문에 따라 어떤 공급자를 사용해야하는지, 이 엔진은 고객이 조정, 수정 및 확장 할 수있는 비즈니스 규칙을 제공하는 동시에 이미 1 단계까지 추적 된 내부 운전자 차량을 사용한다는 점에서 파견 변경을 구축합니다.실제로 특정 운전자에게 주문을 이행합니다.

00:06:11.750 --> 00:06:25.890
또한이 디스패치 계층에는 거리 운전자, 점수 또는 고객이 필요에 따라 비즈니스 로직에 추가하거나 제거 할 수있는 요인을 기반으로 운전자의 우선 순위를 정하는 여러 비즈니스 규칙이 있습니다.

00:06:29.239 --> 00:06:34.769
그래서 제가 언급한 1단계는 대부분 어 검색과 관련이 있었습니다.

00:06:34.779 --> 00:07:01.910
그래서 다각형을 사용하여 라디오를 사용하여 지역에서 운전자를 검색 할 수있는 방법을 제공하십시오. 어, 지오 펜싱을 사용하여 운전자가 교차했는지 확인하십시오.운전자가 소포를 배달하려고합니다.

00:07:01.920 --> 00:07:15.109
동시에 우리는 배터리 최적화에도 많은 관심을 기울이고 있습니다. 이 응용 프로그램은 아마도 하루 68 시간 동안 운전자에게 사용될 것입니다.

00:07:15.119 --> 00:07:22.510
그래서 우리가 이것을 고려하고 있는 설계 결정의 일부이며, 이 요소도 고려합니다.

00:07:22.519 --> 00:07:46.279
우리는 또한 매핑 솔루션을 사용하여 80a에 라우팅을 추가하여 운전자가 지점에서 지점으로 이동해야하며 맵에서 코딩 및 어 정의 된 영역을 코딩하는 방법이 있어야합니다. 높은 수준의 관점에서 첨부 된 여러 구성을 제공합니다.

00:07:46.290 --> 00:07:56.519
어 이것은 우리가 실제로 고객에게 기술 어 공무원의 관점에서 제공하는 것입니다. 음, 대부분 마이크로 서비스와 같습니다.

00:07:56.529 --> 00:07:58.950
마이크로서비스 기반 접근법.

00:07:58.959 --> 00:08:04.049
우리는 짝수 소싱 어 패턴으로 사용합니다.

00:08:04.049 --> 00:08:21.109
그래서 우리는 글로벌 계층에서 서비스 간의 메시지를 변경하는 데 uh를 사용하기도합니다. 그러나 대부분의 결과물은 운전자를 검색 할 수있는 기능을 제공하고 있다고 말할 것입니다.

00:08:21.119 --> 00:08:55.320
그래서 우리는 대부분 반경을 사용하여 드라이버를 쿼리하고 반경 내에 사용하는 간단하고 간단한 위치 검색 레이어를 가지고 있습니다. 왜 우리는 더 복잡한 검색 기능을 사용하여 고객이 다각형과 같은 복잡한 모양을 사용하여 운전자를 신용 할 수 있도록하고 실제로 elasticsearch를 사용하여 테스트합니다.그들이 문제 진술에 있던 전제의 일부는, 아시다시피, 안료를 만나기 위해 이것을 확장할 수 있다는 것입니다.

00:08:55.330 --> 00:09:02.739
실제로 수천 명의 운전자의 행동을 동시에 시뮬레이션할 수 있는 시뮬레이터를 구축합니다.

00:09:02.750 --> 00:09:17.140
그리고 어, 우리가 실제로 그 음 요구 사항을 충족 할 수 있는지 확인하십시오. 우리는 또한 고객이 알 수 있도록 데이터 유출의 토대를 마련합니다.

00:09:17.150 --> 00:09:29.359
따라서 드라이버에서 오는 모든 위치 데이터가 S 3 버킷으로 수집되어 결국 고객이 기계 학습 또는 기타 분석을 수행하는 데 사용됩니다.

00:09:29.369 --> 00:09:40.409
다시 말하지만, 제가 언급했듯이 조 펜싱은 1 단계의 일부였으며 알림도 확장으로 사용할 수있었습니다.

00:09:41.840 --> 00:09:44.469
2 단계는 디스패치 변경만을 중심으로 진행되었습니다.

00:09:44.479 --> 00:10:34.789
어, 그리고 여기서 볼 수 있듯이, 저는 그냥 거기에 넣었지만, 1 단계가 실제로 우리가 2 단계를 위해해야 할 일을 미리 생각하고 설계하는 방법으로 받아 들여졌습니다. 이전에 언급 한 2 단계 시험은 1 단계보다 상당히 복잡합니다.실제 추적 솔루션이지만 이러한 주문을 발송하고 비즈니스 규칙을 사용하여 무엇을 사용할 것인지 결정하는 것이 더 중요합니다. 그렇죠?그래서 우리는 솔루션에 여러 계층의 선택 사항이 있습니다. 첫 번째 계층은 um 주문이 진행되는 곳이고, 제공된 규칙 엔진이라고 부르는 것은 특정 주문에 사용할 제공을 결정할 것입니다.

00:10:34.799 --> 00:10:41.270
그리고 여기에도 비즈니스 규칙이 적용되며 고객이 계속 진행하면서 확장하고 수정할 수 있는 내용이 있습니다.

00:10:41.280 --> 00:10:59.840
어, 하지만 간단한 것은 주문의 약 50% 가 한 공급자에게 보내는 것만 큼 간단 할 것입니다. 주문이 특정 식당에서 온 것이라면 외부 공급자와 같은 특정 공급자에게 보내도록 배달합니다.

00:10:59.849 --> 00:11:10.450
그래서 우리는 이런 종류의 보호 계층을 제공하여 이동 중이거나 배포 할 때 제공되는 uh 제거를 비활성화 할 수있는 기회를 제공합니다.

00:11:10.460 --> 00:11:40.909
이것은 내부 공급자에게 더 많은 것입니다. 우리가 실제로 우리가있는 운전자 함대를 사용할 곳입니다. 우리는 1 단계에서 실제로 신자 주문까지 추적하고 있습니다.나오면 매우 짧은 시간 안에 해결할 수 있습니다.

00:11:40.919 --> 00:11:45.369
그래서 우리는 몇 초 만에 그 과제를 해결하는 것을 보고 있었습니다.

00:11:45.380 --> 00:11:50.820
따라서 검색 공간이 매우 크면 장애가 약화될 수 있습니다.

00:11:50.820 --> 00:11:59.500
그래서 우리는 Joe 클러스터링을 제공하여 특정 지역 주변의 주문을 해당 라우팅과 함께 클러스터링했습니다.

00:11:59.500 --> 00:12:14.770
Pirri에게 실제로 드라이버를 효과적으로 쿼리할 수 있는 무언가를 하기 위해 직면해야 했던 기능만 제공하는 1단계부터 문제의 한 부분이었습니다.

00:12:14.780 --> 00:12:39.359
그리고 그 중 한 부분은 얼음 애크런의 어, 클러스터를 제공함으로써 생성 될 수 있습니다. 그래서 당신은 말할 수 있습니다, 알다시피, 이 시점부터 5 분 또는 10 분 떨어진 멋진 배경을 제공하십시오.결국 명령에 할당했습니다.

00:12:39.840 --> 00:12:51.890
인구 통계 학적 영역도 정의되며 주로 도시의 특정 지역에만 적용되는 구성 가능한 구성 규칙을 갖는 데 필요합니다.

00:12:51.900 --> 00:13:05.250
그래서 제가 여기서 제공된 규칙 엔진에 대해 이야기 할 때, 거기에 연결된 비즈니스 경로가 있습니다. 하지만 그 비즈니스 뿌리는 실제로 어, 음, 영역에서 비롯된 것입니다.따라서 면적이 정의되고 영역에 부착됩니다.

00:13:05.260 --> 00:13:20.510
어 그리고 어 각 영역은 서로 다른 비즈니스 뿌리를 가질 수 있습니다. 다른 배포판과 동일합니다. 인구 통계 영역이나 올바른 두 번째 관리에 따라 조정할 수있는 다른 제약 조건이 있습니다.

00:13:20.510 --> 00:13:32.849
우리가 알아야 할 것이 전부입니다. 앞서 언급했듯이 우리는 균등 한 접근 방식을 가지고 있기 때문에 이것을 효과적으로 관리 할 방법이 필요했습니다.

00:13:33.640 --> 00:13:35.599
Mhm 높은 수준의 구성 요소.

00:13:35.609 --> 00:13:41.979
Phase 1과 비슷하게, 우리는 대부분 아키텍처로서 그것을 붙였습니다.

00:13:41.989 --> 00:13:44.030
글로벌 이벤트 허브는 여전히 존재합니다.

00:13:44.039 --> 00:14:24.539
어, 그리고 우리는 방금 더 많은 서비스를 가지고 있었는데, 전에 언급했기 때문에 모든 배포 디스패치, 오케스트레이터 계층은 앞서 언급하지 않았지만 매우 중요한 구성 요소입니다. 조 클러스터링 라우팅 최적화, 어 우리가 만든 외부 제공 통합, 어통합 할 외부 제공이 없다는 점을 감안할 때 프로토 타입을 조롱했지만 고객이 제공된 배포와 이전에 언급했던 제공된 규칙 엔진과 모든 수명주기 관리를 실제로 확장 할 수있는 기반을 제공합니다.

00:14:24.549 --> 00:14:57.039
2 단계에도 동일한 시뮬레이터가 제공되며, 대부분 1 단계에서 수행 한 작업의 확장이며, 시뮬레이션 한 엔티티에 대한 추가와 함께 2 단계는 이미 1 단계 알림에도 있었고 어 프로토 타입의 범위가 아닌 다른 서비스가있었습니다.우리는 여전히 어느 정도 표시해야했습니다. 단지 끝에서 끝까지 흐름을 실제로 시뮬레이션할 수 있는 방법을 갖기 위해서입니다.

00:14:57.039 --> 00:15:03.770
맞죠?따라서 고객과 식당이 없었다면 실제로 모든 것을 시뮬레이션하기가 매우 어려웠을 것입니다.

00:15:03.770 --> 00:15:54.760
맞죠?그래서 우리는 이러한 서비스가 프로세스 ID를 위해 현대 학교에 있었음에도 불구하고 우리가 전달하려는 전제가 무엇인지 보여줄 수 있다는 것을 분명히했습니다. 문제 진술로 요약하려고했습니다.오늘은 매우 짧은 시간이지만 몇 주 전에 실행했던 시뮬레이션 중 하나를 보여 드리겠습니다. 어, 제가 말했듯이, 그래서 이것은 우리가 프로토 타입과 함께 만든 시뮬레이터입니다. 음, 대부분 음, 1 단계를 알고 있습니다.1 단계에서 우리가 한 일의 확장.

00:15:54.840 --> 00:15:58.830
여기서 제가 얘기했던 인구통계학적 영역을 볼 수 있습니다.

00:15:58.840 --> 00:16:09.549
그래서 여기 세 개의 큰 층은 인구 통계 학적 영역입니다. 구성도 다루었습니다. 우리는이 세 영역에서 운전자 관습 식당에 대해 이야기했습니다.

00:16:09.559 --> 00:16:17.719
이 시스템 상태 페이지는 실제로 시스템에서 무슨 일이 일어나고 있는지 이해하기 위해 프로젝트 전체에 실제로 구축된 것입니다.

00:16:17.719 --> 00:16:26.229
우리는 아키텍처의 특성과 이벤트 중심의 접근 방식을 고려할 때 어떤 일이 일어나고 있는지 이해하기가 매우 어렵다는 것을 어느 시점에서 깨달았습니다.

00:16:26.239 --> 00:16:40.840
그래서 이 페이지는 실제로 짝수 브리지에 게시된 모든 이벤트를 듣고 통계를 쌓고 있습니다. 라이브 데모가 있을 때 나타나서 실제로 움직이는 것을 볼 수 있습니다.

00:16:40.840 --> 00:16:46.770
하지만 지금은 불가능하지만 실제로 무엇을 하는지 설명하겠습니다.

00:16:46.780 --> 00:16:56.960
그래서 여기에 국제적으로, 우리는 시스템에 들어오는 주문이 있습니다. 주문은 첫 번째 오케스트레이션 계층을 거쳐 사용할 것을 결정합니다.

00:16:57.039 --> 00:17:16.229
우리는 대부분의 주문이 결국 전달 될 것으로 예상되는 방식으로 실제로 상황이 행동하고 있는지 확인하기 위해 제어 계층에서 4% 인 기본 거부율을 가지고 있으며 간을 얻는 방식은 이지도에서 볼 수 있듯이 여러 공급자에게 할당됩니다.

00:17:16.239 --> 00:17:21.699
죄송합니다. 이 차트에서 um 내부 공급자는 우리가 사용하려는 구성을 기반으로 한 것입니다.

00:17:21.699 --> 00:17:38.829
이 제품은 주문이 거의 조롱되는 동안 대부분의 주문을 받지만 실제로 다가오는 주문을 슬라이드 할 수 있고 특정 주문에 사용할 것을 선택적으로 선택할 수 있음을 보여줍니다.

00:17:38.839 --> 00:17:40.959
어, 그거.

00:17:40.969 --> 00:18:00.250
어, 이 부분은 대부분이 시점에서 필요하지 않은 이들 중 일부를 제거 할 것입니다. 하지만이 부분은 대부분 배송의 어느 단계에서 특정 공급자를 위해 오는 주문에 나타나는 어 주위에 있습니다.

00:18:00.260 --> 00:18:13.579
음, 이제 설계하기 때문에 마무리되었지만 실제로 시뮬레이션을 실행하면 독립적 인 상태 처리가 진행되고 결국 마무리되는 것을 볼 수 있습니다.

00:18:13.589 --> 00:18:26.479
Um 두 주문 모두 끝에서 끝까지 전달할 수 없지만 모의 공급자의 경우 단순한 시뮬레이터가 아닙니다.

00:18:26.479 --> 00:18:47.229
따라서 내부 제공자를 위해 매우 간단한 구현만 할 수 있습니다. 실제로 운전 행동도 시뮬레이션합니다. 경로를 생성하기 때문에 운전자는 실제로 경로를 통과하고 이번에는 운전자가 실제로 전달해야 하는 경로를 시뮬레이션하는 데 시간이 걸립니다.과거.

00:18:47.239 --> 00:18:55.599
그리고 여기, 운전자가 얼마나 많은 명령을 작성했는지에 대한 아주 간단한 분석입니다.

00:18:55.599 --> 00:19:11.949
따라서 가장 중요한 부분은 실제로 파견 문제라는 것을 줄이십시오. 이는 내부 공급자에게 오는 주문을 받고 특정 운전자에게 할당하려고 시도하는 것입니다.

00:19:11.959 --> 00:19:18.530
그래서 이것은 우리가 내부 공급자에게 주문을 받을 때 만든 테이블입니다.

00:19:18.540 --> 00:19:33.989
그리고 이것들 중 하나로 축소하면 기본적으로 특정 시점에 대해 우리는 일정량의 주문을받을 수 있었고 볼 수 있듯이 서로 상당히 가깝다는 것을 알 수 있습니다.

00:19:34.000 --> 00:19:45.060
그래서 그 사이에 지리적 클러스터링 레이어가 지속되는 농담이 있기 때문에 실제로 퍼지고 위치에 따라 주문을 모으고 있습니다.

00:19:45.069 --> 00:19:52.630
그리고 우리는 그 명령을 사용 가능한 운전자에게 할당하려고 노력합니다.

00:19:52.640 --> 00:20:05.160
그래서 조금 가정하고 있지만, 이 시점에서는 매우 혼란 스럽습니다. 하지만 실제로 특정 운전자를 데리고 운전자가 겪는 경로를 볼 수있는 방법이 있습니다.

00:20:05.170 --> 00:20:13.619
어, 그리고 알다시피, 운전자가 특정 주문에 올바르게 할당되었는지 여부를 정의한 제어 계층입니다.

00:20:13.630 --> 00:20:15.719
어, 지정된 운전기사가 있습니다.

00:20:15.719 --> 00:20:42.650
이것은 정상적인 현상입니다. 들어오는 주문을 통해 할당을 최적화 할 수 있고 때로는 운전자가 할당되어 경로를 볼 수 없을 수도 있습니다. 실제로 방지 할 잠금 메커니즘이있는 오케스트레이션 계층이 있기 때문입니다.솔버를 여러 번 병렬로 실행하면 드라이버에 최적화되지 않는 두 가지 차수가 할당됩니다.

00:20:42.660 --> 00:21:06.390
어, 그래서 그것은 어 파견이 바뀌는 부분입니다. 그리고 그것은 정말로 이것이 프로토 타입의 핵심입니다. 어, 상대방은 우리가 정의한 모든 다각형 영역이라고 말할 것입니다.

00:21:06.400 --> 00:21:17.900
이것은 기본적으로 우리가 1 단계를 위해 구축 한 위치 서비스이며 간단한 라디오로 빠르게 다각형에 의해 자유롭게 될 수있는 방법이 있습니다. 그리고 그것들은 우리가 정의하는 다각형입니다.

00:21:17.910 --> 00:21:23.579
우리는 심지어 당신 자신의 다각형을 가지고 있습니다. 제이슨과 어, 그리고 그 운전자를 쿼리합니다.

00:21:23.589 --> 00:21:51.900
어, 비슷한 부분은 제가 처음에 언급했던 것입니다. 엔티티를 시뮬레이션 할 수있는 방법이 있습니다. 어, 어, 어, 나는 이것을 너무 많이 겪지는 않겠지 만, 우리가 고객 레스토랑과 운전자를 가지고있는 것은 단지 3 ~ 3 개의 주요 실체에 불과합니다.이를 통해 달성하고자 하는 규모에 기반한 시스템입니다.

00:21:51.910 --> 00:22:15.949
프레젠테이션의 다음 부분을 통해 도움이 될 Greg에게 넘겨 줄 수 있다고 생각합니다. 신기루에게 감사 드리며 중단 한 부분부터 계속하겠습니다.

00:22:15.959 --> 00:22:25.270
이 프로토 타입을 개발하면서 배운 과제, 해결책 및 교훈에 대해 이야기하겠습니다.

00:22:26.439 --> 00:22:51.829
그래서 우리의 첫 번째이자 가장 큰 도전은 넓은 범위였습니다. 아시다시피, 우리는 많은 것을 구현해야했고, 이 전체 프로토타입에는 많은 다른 움직이는 부분이 있었기 때문에 가능한 한 많은 서비스와 범위를 다루려고 노력합니다.

00:22:51.839 --> 00:23:10.849
음, 이것이 모든 구성 요소가 비어 있다는 의미는 아니지만 일부 부분은 조롱이나 간단한 구현을 사용하면서 개선 및 준비 또는 프로덕션 방법에 대한 자세한 설명을 제공했습니다.

00:23:13.439 --> 00:23:22.170
그래서 첫 번째 주요 문제는 할당 문제와 주문에 운전자를 할당하는 방법이었습니다.

00:23:22.640 --> 00:23:39.790
우리에게는 여러 파트너가 있습니다. 어, 외부에 있고 고객과 계약을 맺은 사람들과 고객이 운전자 차량을 소유하고 있습니다. 그런 다음 다양한 주문이 들어오고 서명 방법을 찾아야합니다.

00:23:39.800 --> 00:23:48.050
매우 복잡한 문제이며 특히 규모가 크고 분당 약 1000 개의 주문을 처리해야하는 경우 특히 그렇습니다.

00:23:48.060 --> 00:23:53.260
음, 그래, 꽤 복잡해질 수 있습니다.

00:23:54.839 --> 00:24:04.050
따라서 가장 먼저, 주문 분배의 첫 번째 계층은 주문에 적합한 공급자를 선택하는 것입니다.

00:24:04.839 --> 00:24:07.780
하지만 앞서 언급했듯이 여러 공급자가 있습니다.

00:24:07.790 --> 00:24:13.619
하나는 고객의 내부 차량을 대표하고 다른 하나는 외부 계약자를 대표합니다.

00:24:13.630 --> 00:24:18.079
또한 복잡한 비즈니스 규칙도 고려해야 합니다.

00:24:18.079 --> 00:24:25.579
Mirage가 이미 언급 한 내용은 공급자 당 주문 비율을 제어하는 방법과 같습니다.

00:24:25.579 --> 00:24:37.770
어, 우리는 주문의 절반을 내부 함대로 보낸 다음 30% 를 계약에 따라 가장 큰 계약자 중 한 명에게 주문의 30% 를 보냅니다.

00:24:37.780 --> 00:24:50.810
어 우리는 지역이나 특정 식당에서 공급자를 제외하거나 자체 UM 배달 함대가있는 레스토랑이 있다고 가정 해 보겠습니다.

00:24:50.819 --> 00:24:54.760
그리고 우리는 이 모든 명령을 죽음의 함대로 보내고 싶습니다.

00:24:54.770 --> 00:25:04.770
따라서 이러한 모든 비즈니스 규칙은 모든 um 지역 또는 모든 지리적 영역에 대해 매우 복잡하고 사용자 정의된다는 것을 알고 있습니다.

00:25:04.780 --> 00:25:11.209
또한 기술적 관점에서 우리는 여러 공급자 a P와 통합해야합니다.

00:25:11.209 --> 00:25:11.280
I.

00:25:11.280 --> 00:25:11.449
S.

00:25:11.449 --> 00:25:13.000
그건 다릅니다.

00:25:13.000 --> 00:25:15.819
그들은 사용자 정의되었으며 맞춤형 솔루션입니다.

00:25:15.819 --> 00:25:20.030
마찬가지로 어 폴링 주문 상태를 지원합니다.

00:25:20.030 --> 00:25:24.280
다른 하나는 동시에 여러 주문을 폴링하는 것을 지원합니다.

00:25:24.290 --> 00:25:31.000
다른 사람들은 콜백과 웹 후크를 사용하여 주문 상태 변경에 대한 알림을 보내고 있습니다.

00:25:31.000 --> 00:25:49.770
기술적 관점에서 볼 때, 어, 이것들은 모두 상당히 큰 도전과 같습니다. 우리가 해결해야 할 것은 내부 및 외부 공급자 모두를 처리 할 수있는 유연한 서비스를 설계하는 것과 같습니다.

00:25:50.540 --> 00:25:55.280
따라서 우리의 솔루션은 기본적으로 두 가지 주요 구성 요소입니다.

00:25:55.290 --> 00:26:02.119
첫 번째는 공통 A를 공유하는 제공자에 대한 추상화를 만들었다는 것입니다.

00:26:02.119 --> 00:26:02.349
P.

00:26:02.349 --> 00:26:02.670
I.

00:26:03.239 --> 00:26:04.420
부작용으로.

00:26:04.430 --> 00:26:07.729
이는 내부 및 외부 제공자를 동일한 방식으로 취급합니다.

00:26:07.729 --> 00:26:16.260
따라서 새 공급자를 지원해야 하는 경우 공급자 인스턴스를 구현하여 시스템에 연결하기만 하면 됩니다.

00:26:16.640 --> 00:26:23.560
두 번째 구성 요소는 비즈니스 규칙에 따라 적절한 공급자를 선택할 수 있는 규칙 엔진입니다.

00:26:25.239 --> 00:26:35.130
따라서 이러한 통합을 테스트하기 위해 몹 공급자를 만들고 간단하고 기본적인 기능으로 외부 공급자를 시뮬레이션했습니다.

00:26:35.140 --> 00:26:56.560
또한 내부 공급자를 웹 후크 공급자로 구현했으며 그 결과 강력하고 유연한 솔루션이 탄생했습니다. 우리는 표시 할 3 개의 공급자와 하나의 구체적인 구현으로 시스템을 테스트 할 수 있었고 그 과정에서 접수 된 고객 요청을 자연스럽게 해결했습니다.

00:26:56.560 --> 00:27:07.040
그래서 그들은 거부된 주문에 대한 풀백 메커니즘처럼 um을 만들고 싶었습니다.

00:27:07.050 --> 00:27:13.160
주문이 들어오고, 한 공급자에게 할당되어 거부되고 있다고 가정해 보겠습니다.

00:27:13.170 --> 00:27:47.890
어, 그리고 그들이 하고 싶었던 것은 시스템에있는 모든 제공자에게 이것을 알아내는 것입니다. 기본적으로 가장 빠른 첫 번째 사람에게 응답하고 그 주문에 먼저 응답하거나 수락하고 구현하는 것을 좋아하는 사람을 기다리는 것입니다.팬아웃 제공자라고 부르는 다른 공급자를 소개하고이 로직을 내부적으로 처리하면됩니다.

00:27:47.900 --> 00:27:52.560
하지만 실제 음 ap는 그대로 유지됩니다.

00:27:56.040 --> 00:28:02.160
다음은 주문에 대한 운전자 할당을 최적화하는 방법이었습니다.

00:28:03.140 --> 00:28:10.380
따라서 내부 공급자에서 모든 주문을 받고 이러한 주문을 운전자에게 서명하고 싶습니다.

00:28:10.390 --> 00:28:19.180
하지만 이러한 음, 우리는 기본적이고 효율적이며 최적이라고 부르는 여러 가지 전략을 가지고 있습니다.

00:28:19.189 --> 00:28:29.859
따라서 기본 um 전략에서 우리가 하는 일은 운전자당 하나의 주문을 할당하는 것입니다.

00:28:30.239 --> 00:28:54.439
음, 이것이 이 프로토타입의 주요 목표였고, 두 번째와 세 번째는 효율적이고 최적이었습니다. 비극은 어디에 있습니까?운전자당 여러 주문을 할당하는 것 같나요?두 가지 주요 접근 방식이 있습니다.

00:28:54.449 --> 00:29:02.770
하나는 순차라고 부르는 것인데, 여기서 우리는 하나의 주문 배송을 원자 단위로 처리하고 있습니다.

00:29:03.140 --> 00:29:15.160
그리고 우리는 운전자에게 여러 주문을 할당 할 때와 같습니다. 이는 배송되는 주문의 실질적인 흐름과 같습니다.

00:29:16.040 --> 00:29:44.949
그리고 실제 최적의 솔루션은 실제 주문 배송을 픽업 및 드롭 오프 음 방문으로 나누는 곳입니다. 이를 함께 혼합하여 최적의 방법, 최적의 경로를 찾을 수 있습니다.고객도 마찬가지입니다.

00:29:44.959 --> 00:30:23.550
그래서 그것은 혼합 픽업, 드롭 오프 시간 제약, 차량 라우팅 문제 구현과 같은 것을 의미하며, 음, 우리는 두 번째 솔루션을 구현하기위한 솔루션을 찾았습니다. 음, 우리가 그렇게 큰 범위를 가졌다면, 스트레치 목표를 위해 음 승리하는 것처럼 꽤 좋았습니다.최적의 솔루션처럼 um은 조금 더 복잡하지만 분명히 구현할 수 있습니다.

00:30:25.439 --> 00:30:45.459
다음 단계는 확장 및 통합이었습니다. 50,000명의 온라인 드라이버를 위해 시스템을 확장하고 분당 1000개의 수신 주문을 처리하는 방법은 무엇입니까?

00:30:46.439 --> 00:31:11.459
그래서 인도네시아의 고객과 이것은 거대한 지리적 영역입니다. 들어오는 이러한 주문을 어떻게 처리 할 수 있는지, 그리고 50,000 명의 운전자를 추적하여 시스템으로 들어오는 데이터의 양을 어떻게 처리 할 수 있는지 알고 있습니다.

00:31:11.839 --> 00:31:53.859
그래서 이것은 큰 도전이었습니다. 음, 이 솔루션이 확장되고 어떻게 통합 할 수 있는지 고객에게 어떻게 검증하고 입증 할 수 있습니까? 하지만 여전히 작업중인 시스템은 솔루션 관점에서 볼 때, 어, 규모에 대한 우리의 솔루션은 기본적으로 지리 클러스터링을 사용하는 것이 었습니다.음, 큰 문제를 작은 하위 문제로 분해하고 해당 하위 문제에 대한 해결책을 로컬로 찾습니다.

00:31:53.869 --> 00:32:37.750
그리고 우리는 상대적 근접성을 기반으로 주문을 그룹화하고 있었고, 이 클러스터에서 운전자가 검색하는 것처럼 um을 사용하고 있었기 때문에 우리는 꽤 먼 곳에서 온 운전자를 포함시키는 것을 좋아할 필요가 없었습니다. 우리는 가까운 곳에서 운전자를 포함시킬 수 있습니다.선형 최적화 문제에 대한 공간을 검색하고 이러한 검색 공간이 폭발하여 비교적 짧은 시간 동안 결과를 되 찾을 수 없도록합니다.

00:32:37.760 --> 00:32:52.449
그리고 우리 솔루션의 다른 부분은 시뮬레이터를 만드는 것이었습니다. 그렇죠?시스템에서 무슨 일이 일어나고 있는지, 시스템이 실제로 부하를 처리하는 방법을 시연하고 확인하고 테스트하는 것과 같습니다.

00:32:53.739 --> 00:33:15.439
따라서 시뮬레이터를 구현하고 데모를 본 것과 같은 시뮬레이터는 개발 시간의 1/3이 걸린 시뮬레이터입니다. 실제 시나리오를 시뮬레이션하기 위해 um을 보여주는 것은 매우 복잡했기 때문입니다.

00:33:15.439 --> 00:33:21.959
맞죠?그리고 음, 우리는 최종 솔루션과의 통합을 조롱했습니다.

00:33:21.959 --> 00:33:43.140
따라서 고객은 우리가 보유한 서비스와 um을 통합하는 방법에 대한 실제 기반을 가지고 있으며 반복적 인 프로세스였으며 규모를 테스트하는 동안 문제에 직면했을 때 설계를 여러 번 변경하고있었습니다.

00:33:43.150 --> 00:34:53.429
그래서 우리는 몇 가지 구성 요소의 아키텍처입니다. 우리는 리소스처럼 um의 크기를 조정해야했습니다. 예를 들어, 어 Change는 이미 클러스터 2 응용 프로그램 그룹입니다.키네시스 데이터 스트림을 위해 음 및 Windows를 일치시키고 운동성 um에 대해 um 향상된 팬 아웃을 사용해야했습니다. 보시다시피 테스트하는 동안 이국적인 오류와 문제에 직면했습니다.우리의 시뮬레이터와 우리가 Ah가 9000 개의 fargate 컨테이너를 회전시킬 때 IOT 서비스를 폭격하는 것과 같았습니다. 싱가포르 지역에서는 실제로 준비되지 않았습니다.

00:34:53.439 --> 00:35:12.830
음, 엔지니어들이 이러한 셀프 2 티켓을 어떻게 처리했는지, 그리고 시스템에 어떤 유형의 리소스를 도입했는지처럼 증가하는 것과 같은 모습을 보는 것은 매우 흥미로웠습니다.

00:35:12.840 --> 00:35:28.969
음, 시크릿 서비스 팀원이 계정에서 비정상적인 활동을보고 있기 때문에 사용 사례가 무엇인지 물었습니다.

00:35:29.340 --> 00:35:44.469
계정 한도, 람다 동시성 um E c s 컴퓨팅 파워를 늘려야했고 음 정말 다른 이유 때문에 람다 동시성 한도에 여러 번 도달했습니다.

00:35:44.469 --> 00:36:00.179
때로는 Dynamo dB um 읽기 올바른 용량이 충분하지 않고 제대로 설정되지 않아 올바른 스로틀 이벤트가 발생하여 Auto Scaling으로 변경해야했습니다.

00:36:00.189 --> 00:36:14.340
DC 서비스를 재배포할 때 클라우드 형성 시간이 초과되어 시간이 초과되어 34시간 동안 전체 시스템을 실제로 건드릴 수 없었습니다.

00:36:14.350 --> 00:36:42.699
음, 우리는 실제로 아키텍처이고 구성 요소가 은색의 솔버 였을 때 인스턴스 중 하나처럼 um해야했습니다. 우리는 람다 시간 초과보다 훨씬 오래 걸리는 거리 행렬 계산을 구현하고 있었고 그것을 동기 um으로 변경해야했습니다.동기식 소형.

00:36:43.429 --> 00:37:04.929
네, 이것이 확장에 대한 실제 결과이며, 마지막으로 우리가 도전으로 강조하고 싶었던 것은 고객에게 새로운 기술을 도입했고 고객은 매우 비용에 민감하다는 것입니다.

00:37:04.939 --> 00:37:59.820
그래서 음, 그들은 심지어 주도적 인 아키텍처에 대한 경험이 없었고, 설문 조사 목록이나 IOT에 대한 경험이 없었습니다. 특히 처음에는 1 단계에서 이러한 서비스를 신뢰할 자신감이 없었습니다.인스턴스를 쉽게 만들고 docker 컨테이너 또는 ec 두 인스턴스에 마이크로 서비스로 배포해 보겠습니다. 그래서 우리는 그것들을 소개해야했습니다. 음, 이 모든 새로운 기술에 음, 우리는 또한 레거시 솔루션과 통합해야했습니다.새로운 솔루션을 제공하기 때문에 우리는 그것과의 통합도 제공해야 했습니다.

00:37:59.830 --> 00:38:30.989
그래서 음, 비용에 민감한 관점에서 볼 때 우리는 처음에 설계 결정을 좋아해야했습니다. 예를 들어 위치 서비스 가격이 너무 높았고 당시 일반 가용성이 없었기 때문에 위치 서비스와 추적을위한 사용자 지정 구현을 수행했습니다.우리의 필요에 맞게.

00:38:31.000 --> 00:38:59.439
음, 우리는 Google지도를 사용하는 대신 자체 호스팅 라우팅 um을 사용하기로 결정했습니다. Fargate에서 그래프 호퍼 인스턴스를 호스팅하고 있었는데 어 모바일 슬래시가 있지만 Iot 사용 사례가 있지만 앱 충돌로 약간 해킹해야했습니다.모바일 및 IOT 시나리오.

00:38:59.439 --> 00:39:12.879
따라서 몇 가지 사전 계산을 사용하면 장치가 많으면 100,000 개의 장치처럼 모바일 장치에서 해당 충돌을 사용하고 싶다고 가정 해 보겠습니다.

00:39:12.879 --> 00:39:21.070
충돌 매개 변수 하나를 변경하면 롤아웃하는 데 2,000 달러의 비용이 들며 허용되지 않는 경우가 있습니다.

00:39:21.080 --> 00:39:45.340
그래서 예, 음, 우리는 이러한 모든 개선 작업을 수행 한 다음 작은 해킹을 수행하여 고객에게 비용 효율적인 솔루션을 제공 할 수 있습니다. 결국 시스템에서 운전자를 추적하는 것과 같습니다.

00:39:45.719 --> 00:40:05.739
우리는 한 달에 10 센트에 대한 um 비용 추정에 도달했습니다. 그리고 한 주문을 처리하기 위해 um은 주문 당 uh당 약 3.8 센트였습니다.

00:40:05.750 --> 00:40:11.520
음, 우리는 37 개의 Amazon 또는 aws 서비스를 사용했습니다.

00:40:11.530 --> 00:40:17.320
우리는 다양한 오픈 소스 프레임워크를 사용했습니다. 음, 여러 언어를 사용했습니다.

00:40:17.909 --> 00:40:25.830
이 프로젝트는 람다스에서 패키지를 구축하는 데 80/200과 같은 시간이 걸리는 지점까지 성장했습니다.

00:40:26.310 --> 00:40:40.899
결국 새 계정에 새로 배포했으며 전체 솔루션과 그 영향을 배포하는 데 한 시간 이상이 걸렸습니다.

00:40:40.929 --> 00:41:08.030
음, 그래서 우리가 2 단계에서 작업하는 동안 여행 현지 식사는 이미 1 단계를 시작했기 때문에 분명히 우리는 고객으로부터 신뢰를 얻을 수 있었고 일단 2 단계를 전달하면 음 그들은 그것을 기반으로 구축하기 시작했고 그들은 2 단계를 생산에 배포하는 과정에 있습니다.

00:41:08.040 --> 00:41:12.530
음, 여행은 괜찮습니다. 약 400K를 나타냅니다.

00:41:12.530 --> 00:41:12.679
A.

00:41:12.679 --> 00:41:12.909
R.

00:41:12.909 --> 00:41:13.350
R.

00:41:13.360 --> 00:41:38.899
음, 재사용 관점에서 볼 때 이미 인도네시아의 또 다른 고객이 있는데, 이들은 즉시 배송 서비스이며 그들의 목표는 2021 년 말까지 30 배 확장하는 것이 었습니다. 이 기회는 약 500K를 나타냅니다.

00:41:38.899 --> 00:41:39.719
플러스 A.

00:41:39.719 --> 00:41:39.919
R.

00:41:39.919 --> 00:41:40.330
R.

00:41:40.409 --> 00:41:50.330
음, 이미 약 10일 만에 이 고객을 위해 1단계와 도구를 모두 제공했습니다.

00:41:50.709 --> 00:41:58.620
그리고 음, 우리는 여전히 이런 프로젝트를 진행하고 있습니다.

00:41:58.629 --> 00:42:17.620
음, 우리는 하이퍼 로컬 배송 솔루션으로 브랜딩하고 있으며 Amazon foods는 솔루션의 한 부분, 몇 부분에 관심이 있으며이 프로토 타입을 만드는 데 매우 관심이있는 Q에 이미 두 명의 다른 고객이 있습니다.

00:42:18.199 --> 00:42:23.100
이것이 바로 이 음, 이 프로토타입에 관한 것입니다.

00:42:23.110 --> 00:42:25.310
그리고 우리는 질문을 할 수 있습니다.

00:42:26.000 --> 00:42:26.419
감사합니다.

00:42:50.300 --> 00:42:54.000
좋아요, 여기서 녹화를 중단하세요.

00:42:54.010 --> 00:42:55.540
아무도 질문이 없다면.

00:42:55.540 --> 00:42:56.729
정말 멋졌어요.

00:42:57.600 --> 00:43:01.290
그리고 이것이 어떻게 풀리고 펼쳐지는지 기다릴 수 없습니다. 펼쳐진다고 말해야 합니다.

00:43:01.290 --> 00:43:05.149
의회는 음식 서비스 제공으로 풀립니다.

00:43:05.149 --> 00:43:08.010
약 10 배송 서비스를 생각할 수 있습니다.

00:43:08.010 --> 00:43:08.419
시도해 봤어요

00:43:08.419 --> 00:43:09.520
그들은 이것으로 이익을 얻을 수 있습니다.

00:43:11.399 --> 00:43:11.929
굉장한.

00:43:13.800 --> 00:43:14.020
네.

00:43:14.030 --> 00:43:16.620
팀에게 질문이 있는 사람이 있나요?

